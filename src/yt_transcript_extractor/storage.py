"""
storage.py — DuckDB-backed transcript storage for yt-transcript-extractor.

This module provides persistent storage for YouTube transcripts, organized
by channel.  It enables offline retrieval, full-text search, and
channel-based browsing without re-fetching from YouTube.

The central class is TranscriptStore, a context manager that wraps a DuckDB
connection.  On first use it creates three tables:

    channels → videos → transcript_segments

Each table is created with IF NOT EXISTS, so the schema is safely
idempotent — opening the same database file multiple times won't error.

Usage:
    with TranscriptStore("transcripts.duckdb") as store:
        store.save_transcript(video_id, transcript, metadata)
        channels = store.list_channels()
"""

from __future__ import annotations

from dataclasses import dataclass
from datetime import date, datetime

import duckdb

from yt_transcript_extractor.errors import StorageError
from yt_transcript_extractor.metadata import VideoMetadata


# ---------------------------------------------------------------------------
# Data structures returned by query methods
# ---------------------------------------------------------------------------

@dataclass(frozen=True)
class ChannelRecord:
    """
    Summary of a channel stored in the database.

    Returned by list_channels().  Includes a count of how many videos
    from this channel have been saved.

    Attributes:
        channel_id:   YouTube's internal channel identifier.
        channel_name: Human-readable channel name.
        channel_url:  Full URL to the channel page (may be None).
        video_count:  Number of saved videos from this channel.
    """
    channel_id: str
    channel_name: str
    channel_url: str | None
    video_count: int


@dataclass(frozen=True)
class VideoRecord:
    """
    Summary of a saved video, returned by list_videos().

    Attributes:
        video_id:      The 11-character YouTube video identifier.
        title:         Video title as displayed on YouTube.
        channel_id:    YouTube channel identifier.
        upload_date:   When the video was published (may be None).
        duration_secs: Video length in seconds (may be None).
        language:      Language name of the saved transcript.
        language_code: BCP-47 language code of the saved transcript.
        is_generated:  Whether the transcript was auto-generated by YouTube.
        created_at:    When this record was saved to the database.
    """
    video_id: str
    title: str
    channel_id: str
    upload_date: date | None
    duration_secs: int | None
    language: str | None
    language_code: str | None
    is_generated: bool | None
    created_at: datetime | None


@dataclass(frozen=True)
class SaveResult:
    """
    Result of a save_transcript() call.

    Attributes:
        video_id:        The video that was saved.
        already_existed: True if the video was already in the database
                         (transcript was NOT overwritten).  False if this
                         was a new insert.
    """
    video_id: str
    already_existed: bool


# ---------------------------------------------------------------------------
# SQL schema — executed once when the database is first opened
# ---------------------------------------------------------------------------

_SCHEMA_SQL = """
-- channels: one row per YouTube channel.  Acts as the top-level grouping
-- for videos.  Updated on every save in case the channel renames itself.
CREATE TABLE IF NOT EXISTS channels (
    channel_id   VARCHAR PRIMARY KEY,
    channel_name VARCHAR NOT NULL,
    channel_url  VARCHAR,
    created_at   TIMESTAMP DEFAULT current_timestamp,
    updated_at   TIMESTAMP DEFAULT current_timestamp
);

-- videos: one row per saved video.  Foreign-keys to channels so we can
-- list all videos for a given channel.
CREATE TABLE IF NOT EXISTS videos (
    video_id       VARCHAR(11) PRIMARY KEY,
    channel_id     VARCHAR NOT NULL REFERENCES channels(channel_id),
    title          VARCHAR NOT NULL,
    upload_date    DATE,
    duration_secs  INTEGER,
    language       VARCHAR,
    language_code  VARCHAR,
    is_generated   BOOLEAN,
    created_at     TIMESTAMP DEFAULT current_timestamp
);

-- transcript_segments: the actual transcript text, one row per timed
-- segment.  seq preserves the original ordering from YouTube.
CREATE TABLE IF NOT EXISTS transcript_segments (
    video_id    VARCHAR(11) NOT NULL REFERENCES videos(video_id),
    seq         INTEGER NOT NULL,
    text        VARCHAR NOT NULL,
    start       DOUBLE NOT NULL,
    duration    DOUBLE NOT NULL,
    UNIQUE(video_id, seq)
);

-- Index for fast segment retrieval in order.
CREATE INDEX IF NOT EXISTS idx_segments_video_seq
    ON transcript_segments(video_id, seq);

-- Index for listing videos by channel.
CREATE INDEX IF NOT EXISTS idx_videos_channel
    ON videos(channel_id);
"""


# ---------------------------------------------------------------------------
# TranscriptStore — the main storage class
# ---------------------------------------------------------------------------

class TranscriptStore:
    """
    DuckDB-backed storage for YouTube transcripts.

    Use as a context manager to ensure the database connection is properly
    closed after use:

        with TranscriptStore("transcripts.duckdb") as store:
            store.save_transcript(...)

    The database file is created on first open if it doesn't exist.  The
    schema is applied with IF NOT EXISTS, so re-opening an existing database
    is safe and won't lose data.

    Attributes:
        db_path: Filesystem path to the DuckDB database file.
        conn:    The underlying DuckDB connection (set after __init__).
    """

    def __init__(self, db_path: str = "transcripts.duckdb") -> None:
        """
        Open (or create) a DuckDB database and apply the schema.

        Args:
            db_path: Path to the DuckDB database file.  Defaults to
                     "transcripts.duckdb" in the current working directory.

        Raises:
            StorageError: If the database can't be opened or the schema
                          can't be applied (e.g. permissions, corrupt file).
        """
        self.db_path = db_path
        try:
            self.conn = duckdb.connect(db_path)
            self.conn.execute(_SCHEMA_SQL)
        except duckdb.Error as exc:
            raise StorageError(f"Failed to open database at {db_path}: {exc}") from exc

    # --- Context manager protocol ---

    def __enter__(self) -> TranscriptStore:
        """Return self so the `with` block can use the store directly."""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        """Close the DuckDB connection when leaving the `with` block."""
        self.close()

    def close(self) -> None:
        """
        Close the database connection.

        Safe to call multiple times — DuckDB handles redundant close
        calls gracefully.
        """
        self.conn.close()

    # --- Write operations ---

    def save_transcript(
        self,
        video_id: str,
        transcript,
        metadata: VideoMetadata,
    ) -> SaveResult:
        """
        Save a transcript and its metadata to the database.

        Idempotent: if the video already exists, the call is a no-op and
        returns SaveResult(already_existed=True).  This means re-saving the
        same video is safe and won't create duplicates.

        The channel is upserted (inserted or updated) on every save, so
        channel name changes are picked up automatically.

        Args:
            video_id:   The 11-character YouTube video ID.
            transcript: A FetchedTranscript object (iterable of snippets
                        with .text, .start, .duration attributes).
            metadata:   A VideoMetadata dataclass from fetch_video_metadata().

        Returns:
            A SaveResult indicating whether the video was newly inserted
            or already existed.

        Raises:
            StorageError: If any database operation fails.
        """
        try:
            # Check if this video is already saved — if so, skip the insert
            # entirely.  This keeps the operation idempotent.
            if self.has_video(video_id):
                return SaveResult(video_id=video_id, already_existed=True)

            # Upsert the channel: insert if new, update name/url if it
            # already exists (channels can rename themselves over time).
            self.conn.execute(
                """
                INSERT INTO channels (channel_id, channel_name, channel_url)
                VALUES (?, ?, ?)
                ON CONFLICT (channel_id) DO UPDATE SET
                    channel_name = excluded.channel_name,
                    channel_url  = excluded.channel_url,
                    updated_at   = now()
                """,
                [metadata.channel_id, metadata.channel_name, metadata.channel_url],
            )

            # Extract language info from the FetchedTranscript object.
            # The youtube-transcript-api stores language metadata as attributes
            # on the FetchedTranscript instance.
            language = getattr(transcript, "language", None)
            language_code = getattr(transcript, "language_code", None)
            is_generated = getattr(transcript, "is_generated", None)

            # Insert the video record.
            self.conn.execute(
                """
                INSERT INTO videos
                    (video_id, channel_id, title, upload_date,
                     duration_secs, language, language_code, is_generated)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                """,
                [
                    video_id,
                    metadata.channel_id,
                    metadata.title,
                    metadata.upload_date,
                    metadata.duration_secs,
                    language,
                    language_code,
                    is_generated,
                ],
            )

            # Insert each transcript segment with a sequence number to
            # preserve ordering.  We iterate the transcript and build rows
            # for a batch insert.
            segments = []
            for seq, snippet in enumerate(transcript):
                segments.append((
                    video_id,
                    seq,
                    snippet.text,
                    snippet.start,
                    snippet.duration,
                ))

            if segments:
                self.conn.executemany(
                    """
                    INSERT INTO transcript_segments
                        (video_id, seq, text, start, duration)
                    VALUES (?, ?, ?, ?, ?)
                    """,
                    segments,
                )

            return SaveResult(video_id=video_id, already_existed=False)

        except duckdb.Error as exc:
            raise StorageError(f"Failed to save transcript for {video_id}: {exc}") from exc

    # --- Read operations ---

    def has_video(self, video_id: str) -> bool:
        """
        Check whether a video is already stored in the database.

        Args:
            video_id: The 11-character YouTube video ID.

        Returns:
            True if the video exists in the videos table, False otherwise.
        """
        result = self.conn.execute(
            "SELECT 1 FROM videos WHERE video_id = ?",
            [video_id],
        ).fetchone()
        return result is not None

    def list_channels(self) -> list[ChannelRecord]:
        """
        List all channels that have saved videos, sorted alphabetically.

        Returns a list of ChannelRecord dataclasses, each including a count
        of how many videos have been saved from that channel.

        Returns:
            A list of ChannelRecord objects, sorted by channel_name (case-insensitive).
        """
        rows = self.conn.execute(
            """
            SELECT
                c.channel_id,
                c.channel_name,
                c.channel_url,
                COUNT(v.video_id) AS video_count
            FROM channels c
            LEFT JOIN videos v ON c.channel_id = v.channel_id
            GROUP BY c.channel_id, c.channel_name, c.channel_url
            HAVING COUNT(v.video_id) > 0
            ORDER BY LOWER(c.channel_name)
            """
        ).fetchall()

        return [
            ChannelRecord(
                channel_id=row[0],
                channel_name=row[1],
                channel_url=row[2],
                video_count=row[3],
            )
            for row in rows
        ]

    def list_videos(self, channel_id: str) -> list[VideoRecord]:
        """
        List all saved videos for a given channel, newest first.

        Args:
            channel_id: YouTube's internal channel identifier.

        Returns:
            A list of VideoRecord objects sorted by upload_date descending
            (newest first).  Videos without an upload_date sort last.
        """
        rows = self.conn.execute(
            """
            SELECT
                video_id, title, channel_id, upload_date,
                duration_secs, language, language_code, is_generated,
                created_at
            FROM videos
            WHERE channel_id = ?
            ORDER BY upload_date DESC NULLS LAST
            """,
            [channel_id],
        ).fetchall()

        return [
            VideoRecord(
                video_id=row[0],
                title=row[1],
                channel_id=row[2],
                upload_date=row[3],
                duration_secs=row[4],
                language=row[5],
                language_code=row[6],
                is_generated=row[7],
                created_at=row[8],
            )
            for row in rows
        ]

    def get_transcript(self, video_id: str) -> list[dict]:
        """
        Retrieve stored transcript segments as a list of dicts.

        Each dict has keys: text, start, duration — matching the format
        returned by youtube-transcript-api's to_raw_data().

        Args:
            video_id: The 11-character YouTube video ID.

        Returns:
            A list of segment dicts ordered by sequence number.
            Returns an empty list if the video isn't stored.
        """
        rows = self.conn.execute(
            """
            SELECT text, start, duration
            FROM transcript_segments
            WHERE video_id = ?
            ORDER BY seq
            """,
            [video_id],
        ).fetchall()

        return [
            {"text": row[0], "start": row[1], "duration": row[2]}
            for row in rows
        ]

    def get_transcript_text(self, video_id: str) -> str:
        """
        Retrieve a stored transcript as joined plain text.

        Convenience method that fetches all segments and concatenates their
        text with newlines — equivalent to calling format_text() on a fresh
        fetch, but reads from the local database instead of YouTube.

        Args:
            video_id: The 11-character YouTube video ID.

        Returns:
            A single string with one segment per line.
            Returns an empty string if the video isn't stored.
        """
        rows = self.conn.execute(
            """
            SELECT text
            FROM transcript_segments
            WHERE video_id = ?
            ORDER BY seq
            """,
            [video_id],
        ).fetchall()

        return "\n".join(row[0] for row in rows)

    def get_transcript_doc(self, video_id: str) -> str:
        """
        Retrieve a stored transcript as an HTML document with collapsible sections.

        Groups segments into ~30-second paragraphs wrapped in <details>/<summary>
        blocks.  Produces the same output as format_doc() in extractor.py, but
        reads from the local database instead of YouTube.

        Delegates to extractor.format_doc() with the stored segment dicts
        so the formatting logic stays in one place.  Looks up the video title
        from the DB to use as the HTML document title.

        Args:
            video_id: The 11-character YouTube video ID.

        Returns:
            A complete HTML string with collapsible timestamped sections.
            Returns an empty string if the video isn't stored.
        """
        # Reuse the same format_doc() function from extractor.py.
        # get_transcript() returns a list of dicts with "text", "start",
        # "duration" keys — format_doc() accepts both snippet objects and
        # plain dicts, so this works directly.
        from yt_transcript_extractor.extractor import format_doc

        segments = self.get_transcript(video_id)
        if not segments:
            return ""

        # Look up the video title for the HTML <title> and <h1>.
        row = self.conn.execute(
            "SELECT title FROM videos WHERE video_id = ?",
            [video_id],
        ).fetchone()
        title = row[0] if row else "Transcript"

        return format_doc(segments, title=title)

    def search_transcripts(self, query: str) -> list[dict]:
        """
        Search across all saved transcripts for segments matching a query.

        Uses case-insensitive substring matching (ILIKE) on the segment text.
        Results are grouped by video and ordered by relevance (videos with
        more matching segments first, then by sequence within each video).

        Args:
            query: The search string.  Matched as a substring (not regex).

        Returns:
            A list of dicts, each containing:
                - video_id: which video the match is in
                - title: the video's title
                - channel_name: the channel that published the video
                - seq: segment sequence number
                - text: the matching segment text
                - start: timestamp in seconds where the segment begins
                - duration: segment duration in seconds
        """
        rows = self.conn.execute(
            """
            SELECT
                ts.video_id,
                v.title,
                c.channel_name,
                ts.seq,
                ts.text,
                ts.start,
                ts.duration
            FROM transcript_segments ts
            JOIN videos v ON ts.video_id = v.video_id
            JOIN channels c ON v.channel_id = c.channel_id
            WHERE ts.text ILIKE ?
            ORDER BY v.title, ts.seq
            """,
            [f"%{query}%"],
        ).fetchall()

        return [
            {
                "video_id": row[0],
                "title": row[1],
                "channel_name": row[2],
                "seq": row[3],
                "text": row[4],
                "start": row[5],
                "duration": row[6],
            }
            for row in rows
        ]
